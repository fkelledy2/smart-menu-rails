require 'sidekiq'
require 'limiter/mixin'

class MenuItemImageGeneratorJob
  include Sidekiq::Worker

  sidekiq_options queue: 'limited'

  extend Limiter::Mixin

  limit_method :expensive_api_call, rate: 4, interval: 60, balanced: true

  def perform(genimage_id)
    expensive_api_call(genimage_id)
  end

  private

  def expensive_api_call(genimage_id)
    @genimage = Genimage.find_by(id: genimage_id)
    unless @genimage
      Rails.logger.error "Genimage with ID #{genimage_id} not found"
      return
    end

    @menuitem = @genimage.menuitem
    unless @menuitem
      Rails.logger.error "Menuitem not found for Genimage #{genimage_id}"
      return
    end

    prompt = use_prompt_v2? ? build_prompt_v2 : build_prompt
    Rails.logger.warn("[MenuItemImageGeneratorJob] Prompt for Menuitem #{@menuitem.id} (genimage #{@genimage.id}): #{prompt}")
    response = generate_image(prompt, 1, default_image_size)
    if response.success?
      seed = response['created']
      image_url = response['data'][0]['url']
      begin
        downloaded_image = URI.parse(image_url).open
        # Update genimage with seed
        @genimage.update(name: seed)
        # Attach the image to menuitem
        @menuitem.image = downloaded_image
        @menuitem.save!

        # Ensure derivatives (thumb/large) are (re)generated and persisted
        begin
          GenerateImageDerivativesJob.perform_later('Menuitem', @menuitem.id)
        rescue StandardError => e
          Rails.logger.warn "Failed to enqueue GenerateImageDerivativesJob for Menuitem #{@menuitem.id}: #{e.message}"
        end

        # Update timestamp for downstream cache-busting where needed
        @menuitem.touch

        # NOTE: WebP derivatives are automatically generated by Shrine's ImageUploader
        # See app/uploaders/image_uploader.rb for derivative configuration

        Rails.logger.info "Successfully generated and attached image for Menuitem #{@menuitem.id}"
      rescue StandardError => e
        Rails.logger.error "Error processing image for Genimage #{genimage_id}: #{e.message}"
        raise e
      end
    else
      Rails.logger.error "Failed to generate image for Genimage #{genimage_id}"
    end
  end

  def build_prompt
    section      = @menuitem.menusection
    menu         = section&.menu
    restaurant   = menu&.restaurant

    item_name    = @menuitem.name.to_s.strip
    item_desc    = @menuitem.description.to_s.strip.truncate(100)
    sec_name     = section&.name.to_s.strip
    rest_name    = restaurant&.name.to_s.strip
    rest_desc    = restaurant&.try(:description).to_s.strip.truncate(150)
    rest_img_ctx = restaurant&.imagecontext.to_s.strip.truncate(50)

    # Ensure we have a persisted style profile for this restaurant to maximize consistency across items
    ensure_style_profile!(restaurant)

    style_profile = resolve_style_profile(restaurant).truncate(100)

    parts = []
    parts << "Photorealistic #{item_name}#{" - #{item_desc}" if item_desc.present?}"
    parts << "#{sec_name} section" if sec_name.present?
    parts << "Restaurant: #{rest_name}" if rest_name.present?

    # Combine brand context more efficiently
    brand_bits = [rest_desc, rest_img_ctx].compact_blank.join('. ')
    parts << "Context: #{brand_bits}" if brand_bits.present? && brand_bits.length < 200

    # Concise style direction
    parts << "Style: #{style_profile}" if style_profile.present?
    parts << 'Hero dish centered, shallow depth, soft natural light, 45° angle'
    parts << 'Neutral props, no people/text/logos'

    # Build prompt and ensure it's under 1000 characters
    prompt = join_parts(parts)

    # If still too long, progressively trim less important parts
    if prompt.length > 1000
      # Remove brand context first
      parts = parts.reject { |p| p.start_with?('Context:') }
      prompt = join_parts(parts)
    end

    if prompt.length > 1000
      # Truncate item description further
      item_desc = item_desc.truncate(50) if item_desc.present?
      parts[0] = "Photorealistic #{item_name}#{" - #{item_desc}" if item_desc.present?}"
      prompt = join_parts(parts)
    end

    if prompt.length > 1000
      # Final truncation to ensure we're under limit
      prompt = "#{prompt.truncate(995)}..."
    end

    Rails.logger.debug { "[GenerateImageJob] Final prompt length: #{prompt.length}" } if Rails.env.development?
    prompt
  end

  # --- Prompt V2 (A/B) -------------------------------------------------------
  # Section-aware, structured prompt with negative cues and camera/lighting.
  # Enable with ENV['MENU_IMAGE_PROMPT_V2'] == '1'
  def build_prompt_v2
    section      = @menuitem.menusection
    menu         = section&.menu
    restaurant   = menu&.restaurant

    item_name    = sanitize_text(@menuitem.name, 80)
    item_desc    = sanitize_text(@menuitem.description, 160)
    sec_name     = sanitize_text(section&.name, 60)

    # Keep brand/style concise and consistent
    ensure_style_profile!(restaurant)
    style_profile = sanitize_text(resolve_style_profile(restaurant), 120)
    brand_adj     = distilled_brand_adjectives(restaurant, max: 5)

    tags = section_tags(sec_name)

    lines = []
    # Subject and brief description
    subj = [item_name, (item_desc.present? ? "— #{item_desc}" : nil)].compact.join(' ')
    lines << "Subject: #{subj}."
    # Semantic tags
    lines << "Course: #{tags[:course]}." if tags[:course]
    lines << "Category: #{tags[:category]}." if tags[:category]
    lines << "Cuisine: #{tags[:cuisine]}." if tags[:cuisine]
    lines << "Diet: #{tags[:diet]}." if tags[:diet]
    # Plating/portion and cooking cues
    lines << "Plating: #{tags[:plating]}." if tags[:plating]
    lines << "Texture/Cooking: #{tags[:cooking]}." if tags[:cooking]
    # Background and camera defaults tailored by section
    cam = camera_preset_for(tags[:category] || tags[:course])
    lines << "Background: #{cam[:background]}."
    lines << "Camera/Lighting: #{cam[:camera]}."
    # Style and brand
    lines << "Style: #{style_profile}."
    lines << "Brand: #{brand_adj.join(', ')}." if brand_adj.any?
    # Negative cues to reduce mismatches
    lines << "Negative: no text, no watermark, no people, no hands, no menus, no packaging, no logos."

    prompt = join_parts(lines)
    prompt = prompt[0, 1000]
    prompt
  end

  def use_prompt_v2?
    true
  end

  # Map section name keywords to semantic tags
  def section_tags(sec_name)
    s = (sec_name || '').downcase
    tags = {}
    case s
    when /starter|appetizer|small/i
      tags[:course] = 'starter'
      tags[:plating] = 'small plate, minimal garnish'
    when /main|mains|entree|entrée/i
      tags[:course] = 'main'
      tags[:plating] = 'individual dinner plate, balanced composition'
    when /dessert|sweet|pudding/i
      tags[:course] = 'dessert'
      tags[:plating] = 'dessert plate, elegant presentation'
    when /side/i
      tags[:course] = 'side'
      tags[:plating] = 'small bowl or plate'
    when /drink|beverage|cocktail|wine|coffee|tea/i
      tags[:course] = 'drink'
      tags[:plating] = 'glassware on bar top'
    end

    if s.match?(/pizza/i)
      tags[:category] = 'pizza'
      tags[:cuisine] ||= 'italian'
      tags[:cooking] = 'wood-fired, lightly charred crust'
      tags[:plating] ||= 'full round on wooden peel'
    elsif s.match?(/pasta/i)
      tags[:category] = 'pasta'
      tags[:cuisine] ||= 'italian'
      tags[:plating] ||= 'shallow bowl'
    elsif s.match?(/seafood|fish|oyster|shellfish/i)
      tags[:category] = 'seafood'
      tags[:plating] ||= 'on plate with subtle lemon garnish'
      tags[:cooking] ||= 'fresh, crisp highlights'
    elsif s.match?(/salad/i)
      tags[:category] = 'salad'
      tags[:plating] ||= 'wide bowl, fresh greens'
      tags[:cooking] ||= 'fresh, crisp textures'
    elsif s.match?(/burger|sandwich/i)
      tags[:category] = 'burger'
      tags[:plating] ||= 'stacked on plate or board'
      tags[:cooking] ||= 'grilled, juicy, melted cheese when applicable'
    elsif s.match?(/grill|steak|bbq/i)
      tags[:category] = 'grill'
      tags[:plating] ||= 'centered on plate, rustic sides'
      tags[:cooking] ||= 'grilled, seared, char marks'
    end

    if s.match?(/vegan/i)
      tags[:diet] = 'vegan'
    elsif s.match?(/vegetarian/i)
      tags[:diet] = 'vegetarian'
    elsif s.match?(/gluten[- ]?free|gf/i)
      tags[:diet] = 'gluten-free'
    end
    tags
  end

  def camera_preset_for(kind)
    k = (kind || '').to_s.downcase
    case k
    when 'pizza'
      { background: 'clean rustic wooden tabletop, subtle crumbs', camera: 'top-down 15° tilt, natural soft diffused light, 35–50mm equivalent' }
    when 'salad'
      { background: 'clean table, fresh greens, shallow depth', camera: 'top-down 10–20°, soft daylight, 35mm equivalent' }
    when 'burger'
      { background: 'clean board or plate, minimal props', camera: '3/4 angle, shallow DOF, soft key light, 50mm equivalent' }
    when 'grill'
      { background: 'matte plate on wooden table, moody highlights', camera: '3/4 angle, directional soft light, 50–85mm' }
    when 'starter', 'dessert', 'main', 'side'
      { background: 'clean restaurant tabletop, minimal props', camera: '3/4 angle, shallow DOF, soft natural light, 50mm equivalent' }
    else
      { background: 'clean tabletop, minimal props', camera: '3/4 angle, soft natural light, 50mm' }
    end
  end

  def sanitize_text(text, limit)
    t = text.to_s
    t = ActionView::Base.full_sanitizer.sanitize(t) rescue t
    t = t.gsub(/\s+/, ' ').strip
    return t if t.length <= limit
    t.split[0..].join(' ')[0, limit]
  end

  def distilled_brand_adjectives(restaurant, max: 5)
    return [] unless restaurant
    pool = [restaurant.try(:imagecontext), restaurant.try(:description)].map { |s| s.to_s.downcase }
    words = pool.join(' ').scan(/[a-zA-Z]+/)
    candidates = %w[rustic cozy modern upscale casual coastal vibrant elegant minimalist traditional authentic contemporary warm refined bright moody]
    (candidates & words).first(max)
  end

  def generate_image(prompt, number, size)
    api_key = Rails.application.credentials.openai_api_key
    headers = { 'Authorization' => "Bearer #{api_key}", 'Content-Type' => 'application/json' }
    body = { prompt: prompt, n: number, size: size }.to_json
    Rails.logger.debug body
    HTTParty.post(
      'https://api.openai.com/v1/images/generations',
      headers: headers,
      body: body,
    )
  end

  def ask_question(prompt)
    api_key = Rails.application.credentials.openai_api_key
    headers = { 'Authorization' => "Bearer #{api_key}", 'Content-Type' => 'application/json' }
    body = {
      messages: [{ role: 'user', content: prompt }],
      model: 'gpt-3.5-turbo',
    }.to_json
    HTTParty.post(
      'https://api.openai.com/v1/chat/completions',
      headers: headers,
      body: body,
    )
  end

  # Ensure a restaurant-level image_style_profile exists; if missing, generate a short style guide
  # from available restaurant context via ask_question and persist it.
  def ensure_style_profile!(restaurant)
    return unless restaurant
    return unless restaurant.respond_to?(:image_style_profile)

    current = restaurant.image_style_profile.to_s.strip
    return if current.present?

    # Build a concise context for the LLM
    name      = restaurant.try(:name).to_s.strip
    desc      = restaurant.try(:description).to_s.strip
    img_ctx   = restaurant.try(:imagecontext).to_s.strip

    context_bits = []
    context_bits << "Name: #{name}." if name.present?
    context_bits << "Brand/Cuisine context: #{desc}." if desc.present?
    context_bits << "Image context hints: #{img_ctx}." if img_ctx.present?
    context_text = context_bits.join(' ')

    prompt = <<~PROMPT.strip
      You are a food photography art director. Based on the following restaurant brand context, produce a single-sentence food photography style guide to keep all menu item images visually consistent. Focus on visual style, lighting, angle/lens, props, and color mood. Avoid mentioning people or text. Be concise (max 30 words).
      #{context_text}
    PROMPT

    begin
      resp = ask_question(prompt)
      if resp&.success?
        content = resp.parsed_response.dig('choices', 0, 'message', 'content').to_s.strip
        if content.present?
          restaurant.update_column(:image_style_profile, content)
          Rails.logger.info("Generated image_style_profile for Restaurant ##{restaurant.id}")
        end
      else
        Rails.logger.warn("ask_question failed when generating style profile for Restaurant ##{restaurant.id}")
      end
    rescue StandardError => e
      Rails.logger.error("Error generating style profile for Restaurant ##{restaurant&.id}: #{e.message}")
    end
  end

  # Resolve a reusable, per-restaurant style profile to keep image generations consistent.
  # If your Restaurant model has an image_style_profile column, this method will use it when present.
  # Otherwise, we fall back to a sensible default profile influenced by restaurant context when available.
  def resolve_style_profile(restaurant)
    return default_style_profile unless restaurant

    # Prefer a stored, explicit style profile if the model provides it
    if restaurant.respond_to?(:image_style_profile)
      prof = restaurant.image_style_profile.to_s.strip
      return prof if prof.present?
    end

    hints = [restaurant.try(:imagecontext).to_s.strip,
             restaurant.try(:description).to_s.strip,].compact_blank.join('. ')
    base = default_style_profile
    hints.present? ? "#{base} Brand cues: #{hints}." : base
  end

  def default_style_profile
    'Realistic studio food photography; shallow depth of field; soft natural light; cohesive, muted color palette; matte stoneware plates; rustic wooden table; minimal, tasteful props'
  end

  def join_parts(parts)
    parts.compact.map { |s| s.to_s.strip }.compact_blank.join(' ')
  end

  def default_image_size
    ENV['MENU_IMAGE_SIZE'].presence || '1024x1024'
  end
end
